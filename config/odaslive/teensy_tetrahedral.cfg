# Configuration file for Teensy Ambisonic Microphone Array
# Regular tetrahedral configuration with 4 INMP441 microphones
# 43.3mm radius (center to vertex), 70.7mm edges - matches mechanical/tetrahedron_frame.scad

version = "2.1";

# Raw audio input

raw:
{
    fS = 44100;
    hopSize = 512;
    nBits = 16;
    nChannels = 8;

    # Input from Teensy USB Audio (8-channel)
    # Note: Only first 4 channels used for tetrahedral array
    interface: {
        type = "soundcard";
        card = 0;  # Adjust based on your system - "Teensy Audio" device
        device = 0;
    }
}

# Channel mapping - using first 4 channels for tetrahedral array

mapping:
{
    # Map only the first 4 channels for tetrahedral processing
    # Channels 0-3: Master's local I2S microphones
    # Channels 4-7: Slave's microphones via TDM (not used in tetrahedral config)
    map: (1, 2, 3, 4);
}

# General configuration

general:
{
    epsilon = 1E-20;

    size:
    {
        hopSize = 128;
        frameSize = 256;
    };

    samplerate:
    {
        mu = 44100;
        sigma2 = 0.01;
    };

    speedofsound:
    {
        mu = 343.0;
        sigma2 = 25.0;
    };

    # Tetrahedral microphone array geometry
    # Positions from array_geometry.json (converted to meters)
    # Regular tetrahedron with 43.3mm radius from center to vertices
    mics = (

        # Microphone 0: Vertex (+X,+Y,+Z)
        {
            mu = ( +0.025, +0.025, +0.025 );
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( +0.577, +0.577, +0.577 );  # Outward facing normal
            angle = ( 0.0, 180.0 );  # Full spherical coverage
        },

        # Microphone 1: Vertex (+X,-Y,-Z)
        {
            mu = ( +0.025, -0.025, -0.025 );
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( +0.577, -0.577, -0.577 );  # Outward facing normal
            angle = ( 0.0, 180.0 );
        },

        # Microphone 2: Vertex (-X,+Y,-Z)
        {
            mu = ( -0.025, +0.025, -0.025 );
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( -0.577, +0.577, -0.577 );  # Outward facing normal
            angle = ( 0.0, 180.0 );
        },

        # Microphone 3: Vertex (-X,-Y,+Z)
        {
            mu = ( -0.025, -0.025, +0.025 );
            sigma2 = ( +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000, +0.000 );
            direction = ( -0.577, -0.577, +0.577 );  # Outward facing normal
            angle = ( 0.0, 180.0 );
        }
    );

    # Spatial filter for full spherical coverage
    # No restrictions for 3D ambisonic capture
    spatialfilters = (
        {
            direction = ( +0.000, +0.000, +1.000 );
            angle = (0.0, 180.0);  # Full spherical coverage
        }
    );

    nThetas = 181;
    gainMin = 0.25;
};

# Stationary noise estimation

sne:
{
    b = 3;
    alphaS = 0.1;
    L = 150;
    delta = 3.0;
    alphaD = 0.1;
}

# Sound Source Localization

ssl:
{
    nPots = 4;
    nMatches = 10;
    probMin = 0.5;
    nRefinedLevels = 1;
    interpRate = 4;

    # Multi-resolution scanning for small tetrahedral array
    # Higher resolution needed due to small array size
    scans = (
        { level = 3; delta = -1; },  # Coarse scan
        { level = 5; delta = -1; }   # Fine scan
    );

    # Output potential sources via JSON socket
    potential: {
        format = "json";
        interface: {
            type = "socket";
            ip = "127.0.0.1";
            port = 9001;
        };
    };
};

# Sound Source Tracking

sst:
{
    mode = "kalman";
    add = "dynamic";

    # Active source parameters - tuned for small array
    active = (
        { weight = 1.0; mu = 0.5; sigma2 = 0.0025 }
    );

    inactive = (
        { weight = 1.0; mu = 0.3; sigma2 = 0.0025 }
    );

    sigmaR2_prob = 0.0025;
    sigmaR2_active = 0.0225;
    sigmaR2_target = 0.0025;
    Pfalse = 0.1;
    Pnew = 0.1;
    Ptrack = 0.8;

    theta_new = 0.9;
    N_prob = 5;
    theta_prob = 0.8;
    N_inactive = ( 200, 200, 200, 200 );
    theta_inactive = 0.9;

    kalman: {
        sigmaQ = 0.001;
    };

    particle: {
        nParticles = 1000;
        st_alpha = 2.0;
        st_beta = 0.04;
        st_ratio = 0.5;
        ve_alpha = 0.05;
        ve_beta = 0.2;
        ve_ratio = 0.3;
        ac_alpha = 0.5;
        ac_beta = 0.2;
        ac_ratio = 0.2;
        Nmin = 0.7;
    };

    target: ();

    # Output tracked sources via JSON socket
    tracked: {
        format = "json";
        interface: {
            type = "socket";
            ip = "127.0.0.1";
            port = 9000;
        };
    };
}

# Sound Source Separation (optional)

sss:
{
    mode_sep = "dds";
    mode_pf = "ss";

    gain_sep = 1.0;
    gain_pf = 10.0;

    dds: {
    };

    dgss: {
        mu = 0.01;
        lambda = 0.5;
    };

    dmvdr: {
    };

    ms: {
        alphaPmin = 0.07;
        eta = 0.5;
        alphaZ = 0.8;
        thetaWin = 0.3;
        alphaWin = 0.3;
        maxAbsenceProb = 0.9;
        Gmin = 0.01;
        winSizeLocal = 3;
        winSizeGlobal = 23;
        winSizeFrame = 256;
    };

    ss: {
        Gmin = 0.01;
        Gmid = 0.5;
        Gslope = 10.0;
    }

    separated: {
        fS = 44100;
        hopSize = 512;
        nBits = 16;

        interface: {
            type = "file";
            path = "separated.raw";
        }
    };

    postfiltered: {
        fS = 44100;
        hopSize = 512;
        nBits = 16;
        gain = 10.0;

        interface: {
            type = "file";
            path = "postfiltered.raw";
        }
    };
};

# Sound classification

classify:
{
    frameSize = 2048;  # Adjusted for 44.1kHz
    winSize = 3;
    tauMin = 88;       # Adjusted for higher sample rate
    tauMax = 551;
    deltaTauMax = 20;
    alpha = 0.3;
    gamma = 0.05;
    phiMin = 0.5;
    r0 = 0.2;

    category: {
        format = "undefined";
        interface: {
            type = "blackhole";
        }
    }
}